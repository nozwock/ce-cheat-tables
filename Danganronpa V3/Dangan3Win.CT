<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <CheatEntries>
    <CheatEntry>
      <ID>780</ID>
      <Description>"Base Address [Monocoins]"</Description>
      <Options moManualExpandCollapse="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
      <ShowAsSigned>0</ShowAsSigned>
      <GroupHeader>1</GroupHeader>
      <Address>Dangan3Win.exe+D20080</Address>
      <Offsets>
        <Offset>2636</Offset>
      </Offsets>
      <CheatEntries>
        <CheatEntry>
          <ID>0</ID>
          <Description>"Monocoins"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>2 Bytes</VariableType>
          <Address>+0</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>1</ID>
          <Description>"Skill Fragments"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>2 Bytes</VariableType>
          <Address>-218</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>9</ID>
          <Description>"Casino Coins"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>+88AA</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>10</ID>
          <Description>"S-Tickets"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>+8986</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>11</ID>
          <Description>"U-Tickets"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>+898A</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>4</ID>
          <Description>"Player Level"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>8</ID>
              <Description>"Lv 1-5 = 500 Exp | Lv 6-? = 1000 Exp"</Description>
              <Color>CC0000</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
            <CheatEntry>
              <ID>5</ID>
              <Description>"Total Experience"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>-226</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>6</ID>
              <Description>"Visual Level"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>-22A</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>7</ID>
              <Description>"Reflected Level / Skill Slots"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>-21A</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>313</ID>
          <Description>"Class Trial"</Description>
          <Options moAlwaysHideChildren="1" moManualExpandCollapse="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>314</ID>
              <Description>"Lock Timer, Influence, and Focus"</Description>
              <Color>0000CC</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript><![CDATA[{$lua}
[ENABLE]
local record_value_map = {}

do
	local timer_max_memrec = AddressList.getMemoryRecordByDescription("Timer Max")
	local timer_memrec = AddressList.getMemoryRecordByDescription("Timer")
	record_value_map[timer_memrec.ID] = {
		val = function()
			return timer_max_memrec.Value
		end,
	}

	local influence_max_memrec = AddressList.getMemoryRecordByDescription("Influence Max")
	local influence_memrec = AddressList.getMemoryRecordByDescription("Influence")
	record_value_map[influence_memrec.ID] = {
		val = tostring(math.max(tonumber(influence_max_memrec.Value) or 0, tonumber(influence_memrec.Value) or 0)),
	}

	local class_trial_memrec = AddressList.getMemoryRecordByDescription("Class Trial")
	local focus_max_memrec = AddressList.getMemoryRecordByDescription("Focus Max")
	for i = 0, class_trial_memrec.Count - 1 do
		local child = class_trial_memrec.Child[i]
		if string.match(child.Description, "^Focus") and child.Description ~= "Focus Max" then
			record_value_map[child.ID] = {
				val = tostring(math.max(tonumber(focus_max_memrec.Value) or 0, tonumber(child.Value) or 0)),
			}
		end
	end
end

local lazy_setter = LazyRecordValueSetter:new()
newFreezeTimer(memrec.ID, function()
	for id, t in pairs(record_value_map) do
		lazy_setter:set_value(id, t.val, t.custom_check)
	end
end)
[DISABLE]
dropFreezeTimer(memrec.ID)
]]></AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>300</ID>
              <Description>"Timer"</Description>
              <VariableType>Float</VariableType>
              <Address>Dangan3Win.exe+00C25570</Address>
              <Offsets>
                <Offset>208</Offset>
                <Offset>10</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>301</ID>
              <Description>"Timer Max"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>Dangan3Win.exe+00C25570</Address>
              <Offsets>
                <Offset>20C</Offset>
                <Offset>10</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>310</ID>
              <Description>"Influence"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>-220</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>309</ID>
              <Description>"Influence Max"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>-222</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>312</ID>
              <Description>"Focus"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>-21C</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>311</ID>
              <Description>"Focus Max"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>-21E</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>302</ID>
              <Description>"Focus (Nonstop Debate)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>Dangan3Win.exe+00C25570</Address>
              <Offsets>
                <Offset>218</Offset>
                <Offset>10</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>303</ID>
              <Description>"Focus (Rebuttal Showdown)"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>Dangan3Win.exe+00A23F00</Address>
              <Offsets>
                <Offset>AF40</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>304</ID>
              <Description>"Focus (Argument Armament)"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>"Dangan3Win.exe"+00A23440</Address>
              <Offsets>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>305</ID>
              <Description>"Enemy HP (Argument Armament)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>Dangan3Win.exe+00A23440</Address>
              <Offsets>
                <Offset>68</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>2375</ID>
          <Description>"Chapter 6 Stats"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>2373</ID>
              <Description>"Friendship Power"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>2 Bytes</VariableType>
              <Address>Dangan3Win.exe+00C28088</Address>
              <Offsets>
                <Offset>202E</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>2374</ID>
              <Description>"Countdown To Dawn"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>Dangan3Win.exe+00C28088</Address>
              <Offsets>
                <Offset>9258</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>50</ID>
      <Description>"Handbook Themes"</Description>
      <Options moRecursiveSetValue="1" moAlwaysHideChildren="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>51</ID>
          <Description>"Selected Theme Index"</Description>
          <ShowAsHex>1</ShowAsHex>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>Byte</VariableType>
          <Address>+88E</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>100</ID>
      <Description>"[Table Internal Data]"</Description>
      <Options moAlwaysHideChildren="1" moManualExpandCollapse="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>101</ID>
          <Description>"list/0 Unlocked 1 Locked"</Description>
          <DropDownList ReadOnly="1" DisplayValueAsItem="1">0:Unlocked
1:Locked
</DropDownList>
          <GroupHeader>1</GroupHeader>
        </CheatEntry>
        <CheatEntry>
          <ID>102</ID>
          <Description>"list/1 Unlocked 0 Locked"</Description>
          <DropDownList ReadOnly="1" DisplayValueAsItem="1">1:Unlocked
0:Locked
</DropDownList>
          <GroupHeader>1</GroupHeader>
        </CheatEntry>
        <CheatEntry>
          <ID>4065</ID>
          <Description>"list/0:Not Owned,1:Owned"</Description>
          <DropDownList ReadOnly="1" DisplayValueAsItem="1">0:Not Owned
1:Owned
</DropDownList>
          <GroupHeader>1</GroupHeader>
        </CheatEntry>
        <CheatEntry>
          <ID>4066</ID>
          <Description>"list/0:Viewed,1:Not Viewed"</Description>
          <DropDownList ReadOnly="1" DisplayValueAsItem="1">0:Viewed
1:Not Viewed
</DropDownList>
          <GroupHeader>1</GroupHeader>
        </CheatEntry>
        <CheatEntry>
          <ID>4067</ID>
          <Description>"list/0:Not Selected,1:Selected"</Description>
          <DropDownList ReadOnly="1" DisplayValueAsItem="1">0:Not Selected
1:Selected
</DropDownList>
          <GroupHeader>1</GroupHeader>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
  <Comments><![CDATA[Partially derived record addresses from https://fearlessrevolution.com/viewtopic.php?p=222782#p222782]]></Comments>
  <LuaScript>
    <LuaScriptEntry><![CDATA[---@param record_description string
---@param value string
---@param set_all? boolean
---@param custom_check? fun(memrec: userdata): boolean
function set_child_values(record_description, value, set_all, custom_check)
	local record = AddressList.getMemoryRecordByDescription(record_description)
	assert(record, string.format("Record with description '%s' is not found.", record_description))

	for i = 0, record.Count - 1 do
		local child = record.Child[i]

		local custom_check_result = true
		if custom_check then
			custom_check_result = custom_check(child)
		end

		if not child.IsGroupHeader and (set_all or tonumber(child.Value) > 0) and custom_check_result then
			child.Value = value
		end
	end
end

---@param value string
function set_gifts_quantity(value)
	set_child_values("Gifts Quantity", value, false, function(memrec)
		local id, _ = string.gsub(memrec.Description, "NO%.", "")
        id = tonumber(id)
		return id < 114 or id == 130
	end)
end

-- set_gifts_quantity("25")
]]></LuaScriptEntry>
    <LuaScriptEntry><![CDATA[local function register_main_symbol_if_not_present()
	-- Symbol doesn't exist when running the game under wine/proton on linux
	if not getAddressSafe("Dangan3Win.exe") then
		local scanlist = AOBScan("50 45 00 00 64 86 07 00 BD AA DC 59 00 00 00 00")
		assert(scanlist, "Couldn't find the unique instruction sequence for Dangan3Win.exe")
		registerSymbol("Dangan3Win.exe", string.format("%X", tonumber(scanlist[0], 16) - 0x128), true)
	end
end

function onOpenProcess()
	register_main_symbol_if_not_present()
end

do
	local is_process_already_opened = getOpenedProcessID() ~= 0
	if is_process_already_opened then
		register_main_symbol_if_not_present()
	end
end
]]></LuaScriptEntry>
    <LuaScriptEntry><![CDATA[LazyRecordValueSetter = {
	_cache = {},
	new = function(self)
		return setmetatable({ _cache = {} }, { __index = self })
	end,
}

---@param record_id integer
---@param value string | fun(): string
---@param custom_check? fun(record: userdata): boolean
---@param initial_set_on_cache? boolean
function LazyRecordValueSetter:set_value(record_id, value, custom_check, initial_set_on_cache)
	---@param record userdata
	---@param value string
	local function set_record_value(record, value)
		if record.Value ~= "??" then
			record.Value = value
		end
	end

	---@param record userdata
	---@param value string
	---@param custom_check? fun(record: userdata): boolean
	local function is_value_updated(record, value, custom_check)
		local is_value_updated = false
		if custom_check then
			is_value_updated = custom_check(record)
		else
			is_value_updated = record.Value ~= value
		end

		return is_value_updated
	end

	if type(value) == "function" then
		value = value()
	end

	local cached_record = self._cache[record_id]
	if not cached_record then
		local record = AddressList.getMemoryRecordByID(record_id)
		assert(record)
		if initial_set_on_cache == true and is_value_updated(record, value, custom_check) then
			set_record_value(record, value)
		end
		self._cache[record_id] = { record = record, prev_value = record.Value }
		cached_record = self._cache[record_id]
	end

	if is_value_updated(cached_record.record, cached_record.prev_value, custom_check) then
		set_record_value(cached_record.record, value)
		cached_record.prev_value = value
	end
end

FreezeTimersMap = FreezeTimersMap or {}

---@param id any
---@param callback function
---@param interval_ms? integer
---@return userdata
function newFreezeTimer(id, callback, interval_ms)
	local timer = FreezeTimersMap[id]
	if not timer then
		timer = createTimer()
		FreezeTimersMap[id] = timer
	end

	timer.setOnTimer(callback)
	if interval_ms then
		timer.Interval = interval_ms
	else
		timer.Interval = getFreezeTimer().Interval
	end

	return timer
end

---@param id any
function dropFreezeTimer(id)
	local timer = FreezeTimersMap[id]
	if timer then
		timer.destroy()
		FreezeTimersMap[id] = nil
	end
end

---@class MemoryRecordFreezeOptions
---@field AllowIncrease? boolean
---@field AllowDecrease? boolean

---@param memrec userdata
---@param options MemoryRecordFreezeOptions
---@param reset_previous_callback? boolean
function setMemoryRecordFreezeOptions(memrec, options, reset_previous_callback)
	local cb
	if options.AllowIncrease then
		cb = function(memrec, prev, curr)
			memrec.AllowIncrease = true
			return true
		end
	elseif options.AllowDecrease then
		cb = function(memrec, prev, curr)
			memrec.AllowDecrease = true
			return true
		end
	elseif options.AllowIncrease and options.AllowDecrease then
		cb = function(memrec, prev, curr)
			memrec.AllowIncrease = true
			memrec.AllowDecrease = true
			return true
		end
	else
		return
	end

	if not reset_previous_callback and memrec.OnActivate then
		-- todo: abstract away chaining callbacks into a proper type that manages these callbacks, etc
		local prev_cb = memrec.OnActivate
		memrec.OnActivate = function(memrec, prev, curr)
			prev_cb(memrec, prev, curr)
			cb(memrec, prev, curr)
		end
	else
		memrec.OnActivate = cb
	end
end

---@class DropDownListOptions
---@field DropDownReadOnly? boolean
---@field DropDownDescriptionOnly? boolean
---@field DisplayAsDropDownListItem? boolean

---@alias DropDownMappingList { v: string, as: string }[]
---@param mapping_list DropDownMappingList
---@param name? string
---@param options? DropDownListOptions
---@param parent_description? string
function createDropDownList(mapping_list, name, options, parent_description)
	---@param s string
	---@param unsafe_chars string
	---@param repl? string
	---@return string
	local function quote(s, unsafe_chars, repl)
		if not repl then
			repl = "_"
		end

		return string.gsub(string.gsub(s, "%c+", ""), ".", function(c)
			for i = 1, #unsafe_chars do
				if string.sub(unsafe_chars, i, i) == c then
					return repl
				end
			end
		end)
	end

	---@param mapping_list DropDownMappingList
	---@param n integer
	---@return string
	local function derive_name_from_n_mapping(mapping_list, n)
		local name = "list/"

		for i, t in ipairs(mapping_list) do
			if i > n then
				name = string.gsub(name, "%.+$", "") .. "..."
				break
			end

			local part = string.format("%s:%s", quote(t.v, "/:,"), quote(t.as, "/:,"))
			if i ~= 1 then
				part = "," .. part
			end
			name = name .. part
		end

		return name
	end

	---@param mapping_list DropDownMappingList
	local function generate_drop_down_string(mapping_list)
		local final = ""
		for i, t in ipairs(mapping_list) do
			local part = string.format("%s:%s", quote(t.v, ":", ""), quote(t.as, ":"))
			if i ~= 1 then
				part = "\n" .. part
			end
			final = final .. part
		end

		return final
	end

	if not name then
		name = derive_name_from_n_mapping(mapping_list, 4)
	end

	local memrec = AddressList.getMemoryRecordByDescription(name)
	if not memrec then
		memrec = AddressList.createMemoryRecord()
	end

	memrec.Description = name
	memrec.IsGroupHeader = true
	memrec.DropDownList.clear()
	memrec.DropDownList.addText(generate_drop_down_string(mapping_list))

	if options then
		for k, v in pairs(options) do
			memrec[k] = v
		end
	end

	if parent_description then
		local parent_memrec = AddressList.getMemoryRecordByDescription(parent_description)
		if parent_memrec then
			memrec.appendToEntry(parent_memrec)
		end
	end

	return memrec, name
end
]]></LuaScriptEntry>
    <LuaScriptEntry><![CDATA[local HEADER_DEFAULT_OPTIONS = {
	"moActivateChildrenAsWell",
	"moDeactivateChildrenAsWell",
	"moRecursiveSetValue",
	"moAllowManualCollapseAndExpand",
	"moManualExpandCollapse",
}

---@param group_caption string
---@param is_support_address? boolean
---@return userdata
local function get_or_create_header_group(group_caption, is_support_address)
	local _memrec = AddressList.getMemoryRecordByDescription(group_caption)
	if _memrec ~= nil then
		return _memrec
	end

	local group_memrec = AddressList.createMemoryRecord()
	if is_support_address then
		group_memrec.IsAddressGroupHeader = true
	else
		group_memrec.IsGroupHeader = true
	end
	group_memrec.DontSave = true
	group_memrec.Description = group_caption
	group_memrec.Options = table.concat(HEADER_DEFAULT_OPTIONS, ",")
	group_memrec.Collapsed = true

	return group_memrec
end

---@alias VarType "vtByte" | "vtWord" | "vtDword" | "vtQword" | "vtSingle" | "vtDouble" | "vtString" | "vtByteArray" | "vtGrouped" | "vtBinary" | "vtAll" | "vtAutoAssembler"

--- `i` starts from 1.
---@param base_address string
---@param group_caption string
---@param item_count integer
---@param vartype VarType
---@param vartype_size integer
---@param get_item_caption? fun(i: integer): string
---@return userdata
local function generate_homogeneous_list_group(
	base_address,
	group_caption,
	item_count,
	vartype,
	vartype_size,
	get_item_caption
)
	local _memrec = AddressList.getMemoryRecordByDescription(group_caption)
	if _memrec ~= nil then
		return _memrec
	end

	local group_memrec = AddressList.createMemoryRecord()
	group_memrec.IsAddressGroupHeader = true
	group_memrec.DontSave = true
	group_memrec.Description = group_caption
	group_memrec.Address = base_address
	group_memrec.Options = table.concat(HEADER_DEFAULT_OPTIONS, ",")

	for i = 0, item_count - 1 do
		local offset = i * vartype_size
		local gift_memrec = AddressList.createMemoryRecord()
		gift_memrec.DontSave = true
		if get_item_caption then
			gift_memrec.Description = get_item_caption(i + 1)
		else
			gift_memrec.Description = string.format("%02.0f", i + 1)
		end
		gift_memrec.VarType = vartype
		gift_memrec.Address = "+" .. string.format("%X", offset)
		gift_memrec.appendToEntry(group_memrec)
	end

	group_memrec.Collapsed = true

	return group_memrec
end

--- `i` starts from 1.
---@param base_address string
---@param group_caption string
---@param bit_length integer
---@param dropdown_link? string
---@param get_item_caption? fun(i: integer): string
---@return userdata
local function generate_bitmask_list_group(base_address, group_caption, bit_length, dropdown_link, get_item_caption)
	local _memrec = AddressList.getMemoryRecordByDescription(group_caption)
	if _memrec ~= nil then
		return _memrec
	end

	local group_memrec = AddressList.createMemoryRecord()
	group_memrec.IsAddressGroupHeader = true
	group_memrec.DontSave = true
	group_memrec.Description = group_caption
	group_memrec.Address = base_address
	group_memrec.Options = table.concat(HEADER_DEFAULT_OPTIONS, ",")

	for i = 0, bit_length - 1 do
		local gift_memrec = AddressList.createMemoryRecord()
		gift_memrec.DontSave = true
		if get_item_caption then
			gift_memrec.Description = get_item_caption(i + 1)
		else
			gift_memrec.Description = string.format("%02.0f", i + 1)
		end
		gift_memrec.VarType = "vtBinary"
		gift_memrec.Binary.Startbit = i % 8
		gift_memrec.Binary.Size = 1
		gift_memrec.Address = "+" .. string.format("%X", i // 8)
		if dropdown_link then
			gift_memrec.DropDownLinked = true
			gift_memrec.DropDownLinkedMemRec = dropdown_link
		end
		gift_memrec.appendToEntry(group_memrec)
	end

	group_memrec.Collapsed = true

	return group_memrec
end

---@param is_script_active boolean
local function generate_gift_unlock_on_nonzero_quantity_script(is_script_active)
	local memrec_caption = "Automatically Unlock Gift On Nonzero Quantity"
	local memrec = AddressList.getMemoryRecordByDescription(memrec_caption)
	if memrec ~= nil then
		return
	end

	memrec = AddressList.createMemoryRecord()
	memrec.DontSave = true
	memrec.Description = memrec_caption
	memrec.VarType = "vtAutoAssembler"
	memrec.Script = [[{$lua}
[ENABLE]
_enable_gift_unlock_on_nonzero_quantity()
[DISABLE]
_disable_gift_unlock_on_nonzero_quantity()
]]

	memrec.appendToEntry(get_or_create_header_group("Gifts"))
	memrec.Active = is_script_active
end

---@param group_description string
---@return table<string, userdata>
local function get_description_record_mapping_of_group(group_description)
	local mapping = {}

	local memrec = AddressList.getMemoryRecordByDescription(group_description)
	if not memrec then
		return mapping
	end

	for i = 0, memrec.Count - 1 do
		local child = memrec.Child[i]
		mapping[child.Description] = child
	end

	return mapping
end

local gift_unlock_record_mapping
function _enable_gift_unlock_on_nonzero_quantity()
	local quantity_memrec = AddressList.getMemoryRecordByDescription("Gifts Quantity")
	assert(quantity_memrec)

	for i = 0, quantity_memrec.Count - 1 do
		local child = quantity_memrec.Child[i]
		child.OnValueChangedByUser = function(memrec, prev, curr)
			local mapped_memrec = gift_unlock_record_mapping[memrec.Description]
			if curr ~= "0" and mapped_memrec and mapped_memrec.Value == "1" then
				mapped_memrec.Value = "0" -- Unlocked
			end
		end
	end
end

function _disable_gift_unlock_on_nonzero_quantity()
	local quantity_memrec = AddressList.getMemoryRecordByDescription("Gifts Quantity")
	assert(quantity_memrec)

	for i = 0, quantity_memrec.Count - 1 do
		local child = quantity_memrec.Child[i]
		child.OnValueChangedByUser = nil
	end
end

---@param mapping_list DropDownMappingList
---@param options? DropDownListOptions
---@return userdata, string
local function createTransiantDropDownList(mapping_list, options)
	if not options then
		options = { DisplayAsDropDownListItem = true, DropDownReadOnly = true }
	end

	local memrec, name = createDropDownList(mapping_list, nil, options, "[Table Internal Data]")
	memrec.DontSave = true

	return memrec, name
end

local _, discovered_dropdown_name =
	createTransiantDropDownList({ { v = "0", as = "Discovered" }, { v = "1", as = "Not Discovered" } })

local monocoins_base_address_group = AddressList.getMemoryRecordByDescription("Base Address [Monocoins]")
assert(monocoins_base_address_group)

local GIFTS_COUNT = 143
local gifts_root_group = get_or_create_header_group("Gifts")
gifts_root_group.appendToEntry(monocoins_base_address_group)
generate_homogeneous_list_group("+536", "Gifts Quantity", GIFTS_COUNT, "vtWord", 2, function(i)
	return string.format("NO.%03.0f", i)
end).appendToEntry(gifts_root_group)
generate_bitmask_list_group("+736", "Gifts Unlocked", GIFTS_COUNT, "list/0 Unlocked 1 Locked", function(i)
	return string.format("NO.%03.0f", i)
end).appendToEntry(gifts_root_group)
generate_gift_unlock_on_nonzero_quantity_script(true)
gifts_root_group.Collapsed = true

-- note: Always set this after 'Gifts Unlocked' is created
gift_unlock_record_mapping = get_description_record_mapping_of_group("Gifts Unlocked")

local SKILL_COUNT = 48
local skill_list_root_group = get_or_create_header_group("Skill List")
skill_list_root_group.appendToEntry(monocoins_base_address_group)
generate_bitmask_list_group("+896E", "Skills Selected", SKILL_COUNT, "list/0:Not Selected,1:Selected").appendToEntry(
	skill_list_root_group
)
generate_bitmask_list_group("+8976", "Skills Owned", SKILL_COUNT, "list/0:Not Owned,1:Owned").appendToEntry(
	skill_list_root_group
)
generate_bitmask_list_group("+8966", "Skills Discovered", SKILL_COUNT, discovered_dropdown_name).appendToEntry(
	skill_list_root_group
)
skill_list_root_group.Collapsed = true

local FRIENDS_LIST = {
	"Shuichi Saihara",
	"Kaito Momota",
	"Ryoma Hoshi",
	"Rantaro Amami",
	"Gonta Gokuhara",
	"Kokichi Oma",
	"Korekiyo Shinguji",
	"K1-B0",
	"Kirumi Tojo",
	"Himiko Yumeno",
	"Maki Harukawa",
	"Tenko Chabashira",
	"Tsumugi Shirogane",
	"Angie Yonaga",
	"Miu Iruma",
}
local friendship_fragments_root_group = get_or_create_header_group("Friendship Fragments")
friendship_fragments_root_group.appendToEntry(monocoins_base_address_group)
generate_homogeneous_list_group("+79E", "Friendship Fragments from Kaede POV", #FRIENDS_LIST, "vtWord", 2, function(i)
	return FRIENDS_LIST[i]
end).appendToEntry(friendship_fragments_root_group)
generate_homogeneous_list_group("+7DE", "Friendship Fragments from Shuichi POV", #FRIENDS_LIST, "vtWord", 2, function(i)
	return FRIENDS_LIST[i]
end).appendToEntry(friendship_fragments_root_group)
friendship_fragments_root_group.Collapsed = true

local HANDBOOK_THEME_COUNT = 38
local handbook_theme_root_group = get_or_create_header_group("Handbook Themes")
handbook_theme_root_group.appendToEntry(monocoins_base_address_group)
generate_bitmask_list_group("+776", "Handbook Themes Unlocked", HANDBOOK_THEME_COUNT, "list/1 Unlocked 0 Locked").appendToEntry(
	handbook_theme_root_group
)
generate_bitmask_list_group("+786", "Handbook Themes Viewed", HANDBOOK_THEME_COUNT, "list/0:Viewed,1:Not Viewed").appendToEntry(
	handbook_theme_root_group
)
handbook_theme_root_group.Collapsed = true

local HIDDEN_MONOKUMA_COUNT = 30
local hidden_monokumas_root_group = get_or_create_header_group("Hidden Monokumas")
hidden_monokumas_root_group.appendToEntry(monocoins_base_address_group)
do
	generate_bitmask_list_group(
		"+886",
		"Hidden Monokumas Unlocked [Serialized]",
		HIDDEN_MONOKUMA_COUNT,
		"list/1 Unlocked 0 Locked"
	).appendToEntry(hidden_monokumas_root_group)

	local memrec = generate_bitmask_list_group(
		"Dangan3Win.exe+00C28088",
		"Hidden Monokumas Unlocked",
		HIDDEN_MONOKUMA_COUNT,
		"list/1 Unlocked 0 Locked"
	)
	memrec.setOffsetCount(1)
	memrec.setOffset(0, 0x1034)
	memrec.appendToEntry(hidden_monokumas_root_group)

	local info_memrec = get_or_create_header_group(
		"Only the serialized one persists in saves; other reset to its state on load, but it only takes effect after a save load."
	)
	info_memrec.Options = ""
	info_memrec.Color = 0xCC0000
	info_memrec.appendToEntry(hidden_monokumas_root_group)
end
hidden_monokumas_root_group.Collapsed = true

local EVENT_GALLERY_ITEM_COUNT = 301
local MOVIE_GALLERY_ITEM_COUNT = 59
local SOUND_GALLERY_ITEM_COUNT = 73
local INTIMACY_EVENT_GALLERY_ITEM_COUNT = 126
local extras_root_group = get_or_create_header_group("Extra Menu")
extras_root_group.appendToEntry(monocoins_base_address_group)
generate_bitmask_list_group(
	"-3FE",
	"Event Gallery Purchased Items",
	EVENT_GALLERY_ITEM_COUNT,
	"list/0:Not Owned,1:Owned"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-43E",
	"Event Gallery Unlocked Items",
	EVENT_GALLERY_ITEM_COUNT,
	"list/1 Unlocked 0 Locked"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-36E",
	"Movie Gallery Purchased Items",
	MOVIE_GALLERY_ITEM_COUNT,
	"list/0:Not Owned,1:Owned"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-37E",
	"Movie Gallery Unlocked Items",
	MOVIE_GALLERY_ITEM_COUNT,
	"list/1 Unlocked 0 Locked"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-2CE",
	"Sound Gallery Purchased Items",
	SOUND_GALLERY_ITEM_COUNT,
	"list/0:Not Owned,1:Owned"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-2EE",
	"Sound Gallery Unlocked Items",
	SOUND_GALLERY_ITEM_COUNT,
	"list/1 Unlocked 0 Locked"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-26E",
	"Intimacy Event Gallery Purchased Items",
	INTIMACY_EVENT_GALLERY_ITEM_COUNT,
	"list/0:Not Owned,1:Owned"
).appendToEntry(extras_root_group)
generate_bitmask_list_group(
	"-28E",
	"Intimacy Event Gallery Unlocked Items",
	INTIMACY_EVENT_GALLERY_ITEM_COUNT,
	"list/1 Unlocked 0 Locked"
).appendToEntry(extras_root_group)
extras_root_group.Collapsed = true
]]></LuaScriptEntry>
    <LuaScriptEntry><![CDATA[local record_freeze_options = {
	["Countdown To Dawn"] = { AllowIncrease = true },
}

for description, options in pairs(record_freeze_options) do
	local memrec = AddressList.getMemoryRecordByDescription(description)
	if memrec then
		setMemoryRecordFreezeOptions(memrec, options, true)
	end
end

AddressList.getMemoryRecordByDescription("Countdown To Dawn").OnGetDisplayValue = function(memrec, value)
	local frames = tonumber(value)
	if frames then
		value = tostring(
			(frames // 30) -- ticks, each tick is 30 frames
				// 2 -- seconds, ticks gets decremented twice each second due to 60fps
		) .. (frames == 0 and " second" or " seconds")
	end
	return true, value
end
]]></LuaScriptEntry>
  </LuaScript>
</CheatTable>
